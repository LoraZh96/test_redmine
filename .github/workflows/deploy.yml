name: Infrastructure Deploy

on:
  push:
    branches:
      - prod
  workflow_dispatch:
    inputs:
      run_ansible_only:
        description: 'Run only Ansible deployment'
        required: false
        default: 'false'
      run_terraform_apply:
        description: 'Run terraform apply step'
        required: false
        default: 'true'

permissions:
  contents: write

jobs:
  terraform:
    runs-on: ubuntu-latest
    env:
      TF_WORKDIR: terraform
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
      TF_API_TOKEN: ${{ secrets.TF_API_TOKEN }}
      TF_ORG: ${{ secrets.TF_ORG }}
      TF_WORKSPACE: ${{ secrets.TF_WORKSPACE }}
      TF_VAR_db_username: ${{ secrets.REDMINE_DB_USERNAME }}
      TF_VAR_redmine_db_password: ${{ secrets.REDMINE_DB_PASSWORD }}
    steps:
      - name: Checkout infrastructure repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout application repository
        uses: actions/checkout@v4
        with:
          repository: redmineproject/Redmine-Project
          ref: main
          token: ${{ secrets.APP_REPO_PAT }}
          path: app-repo

      - name: Prepare Redmine artifacts
        run: |
          set -euo pipefail
          rm -rf ansible/redmine
          mkdir -p ansible/redmine/docker
          cp app-repo/deploy/docker-compose.yml ansible/redmine/docker-compose.yml
          cp app-repo/Dockerfile ansible/redmine/Dockerfile
          cp -r app-repo/docker/. ansible/redmine/docker/

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      - name: Terraform fmt check
        if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.run_ansible_only != 'true' }}
        run: terraform fmt -check -recursive
        working-directory: ${{ env.TF_WORKDIR }}

      - name: Configure Terraform credentials
        if: ${{ env.TF_API_TOKEN != '' }}
        run: |
          cat <<EOF > ~/.terraformrc
          credentials "app.terraform.io" {
            token = "${TF_API_TOKEN}"
          }
          EOF

      - name: Terraform init
        if: ${{ env.AWS_ACCESS_KEY_ID != '' && env.AWS_SECRET_ACCESS_KEY != '' && env.AWS_DEFAULT_REGION != '' }}
        run: |
          if [ -n "${TF_API_TOKEN}" ] && [ -n "${TF_ORG}" ] && [ -n "${TF_WORKSPACE}" ]; then
            terraform init -input=false \
              -backend-config="hostname=app.terraform.io" \
              -backend-config="organization=${TF_ORG}" \
              -backend-config="workspaces.name=${TF_WORKSPACE}"
          else
            terraform init -input=false
          fi
        working-directory: ${{ env.TF_WORKDIR }}

      - name: Terraform validate
        if: ${{ env.AWS_ACCESS_KEY_ID != '' && env.AWS_SECRET_ACCESS_KEY != '' && env.AWS_DEFAULT_REGION != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.run_ansible_only != 'true') }}
        run: terraform validate
        working-directory: ${{ env.TF_WORKDIR }}
        env:
          TF_CLOUD_TOKEN: ${{ env.TF_API_TOKEN }}

      - name: Terraform plan
        if: ${{ env.AWS_ACCESS_KEY_ID != '' && env.AWS_SECRET_ACCESS_KEY != '' && env.AWS_DEFAULT_REGION != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.run_ansible_only != 'true') }}
        run: terraform plan -input=false -out=tfplan
        working-directory: ${{ env.TF_WORKDIR }}
        env:
          TF_CLOUD_TOKEN: ${{ env.TF_API_TOKEN }}

      - name: Terraform apply
        if: ${{ env.AWS_ACCESS_KEY_ID != '' && env.AWS_SECRET_ACCESS_KEY != '' && env.AWS_DEFAULT_REGION != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.run_ansible_only != 'true') && (github.event_name != 'workflow_dispatch' || github.event.inputs.run_terraform_apply != 'false') }}
        run: terraform apply -input=false -auto-approve tfplan
        working-directory: ${{ env.TF_WORKDIR }}
        env:
          TF_CLOUD_TOKEN: ${{ env.TF_API_TOKEN }}

      - name: Upload Terraform state artifact
        if: ${{ env.AWS_ACCESS_KEY_ID != '' && env.AWS_SECRET_ACCESS_KEY != '' && env.AWS_DEFAULT_REGION != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.run_ansible_only != 'true') && (github.event_name != 'workflow_dispatch' || github.event.inputs.run_terraform_apply != 'false') }}
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: |
            terraform/*.tfstate
            terraform/*.tfstate.backup

      - name: Commit inventory updates
        if: ${{ github.ref == 'refs/heads/prod' && env.AWS_ACCESS_KEY_ID != '' && env.AWS_SECRET_ACCESS_KEY != '' && env.AWS_DEFAULT_REGION != '' && (github.event_name != 'workflow_dispatch' || github.event.inputs.run_ansible_only != 'true') && (github.event_name != 'workflow_dispatch' || github.event.inputs.run_terraform_apply != 'false') }}
        run: |
          set -euo pipefail
          if git diff --quiet -- ansible/inventory.ini; then
            echo "No inventory changes to commit."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ansible/inventory.ini
          git commit -m "ci: update ansible inventory"
          git push

  ansible:
    runs-on: ubuntu-latest
    needs: [terraform]
    if: ${{ (github.event_name == 'workflow_dispatch' && github.event.inputs.run_ansible_only == 'true') || needs.terraform.result == 'success' }}
    env:
      REDMINE_DB_USERNAME: ${{ secrets.REDMINE_DB_USERNAME }}
      REDMINE_DB_PASSWORD: ${{ secrets.REDMINE_DB_PASSWORD }}
      REDMINE_DB_DATABASE: ${{ secrets.REDMINE_DB_DATABASE }}
      REDMINE_DB_ENCODING: ${{ secrets.REDMINE_DB_ENCODING }}
      REDMINE_DB_PORT: ${{ secrets.REDMINE_DB_PORT }}
      REDMINE_DB_SSLMODE: ${{ secrets.REDMINE_DB_SSLMODE }}
      REDMINE_SECRET_KEY_BASE: ${{ secrets.REDMINE_SECRET_KEY_BASE }}
    steps:
      - name: Checkout infrastructure repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout application repository
        uses: actions/checkout@v4
        with:
          repository: redmineproject/Redmine-Project
          ref: main
          token: ${{ secrets.APP_REPO_PAT }}
          path: app-repo

      - name: Prepare Redmine artifacts
        run: |
          set -euo pipefail
          rm -rf ansible/redmine
          mkdir -p ansible/redmine/docker
          cp app-repo/deploy/docker-compose.yml ansible/redmine/docker-compose.yml
          cp app-repo/Dockerfile ansible/redmine/Dockerfile
          cp -r app-repo/docker/. ansible/redmine/docker/

      - name: Install Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Ansible dependencies
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install ansible
          ansible-galaxy collection install community.general

      - name: Install SSH key
        env:
          BASTION_SSH_KEY: ${{ secrets.BASTION_SSH_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          printf '%s\n' "$BASTION_SSH_KEY" > ~/.ssh/id_ed25519_bastion
          chmod 600 ~/.ssh/id_ed25519_bastion

      - name: Run Ansible playbook
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
          REDMINE_DB_USERNAME: ${{ env.REDMINE_DB_USERNAME }}
          REDMINE_DB_PASSWORD: ${{ env.REDMINE_DB_PASSWORD }}
          REDMINE_DB_DATABASE: ${{ env.REDMINE_DB_DATABASE }}
          REDMINE_DB_ENCODING: ${{ env.REDMINE_DB_ENCODING }}
          REDMINE_DB_PORT: ${{ env.REDMINE_DB_PORT }}
          REDMINE_DB_SSLMODE: ${{ env.REDMINE_DB_SSLMODE }}
          REDMINE_SECRET_KEY_BASE: ${{ env.REDMINE_SECRET_KEY_BASE }}
        run: ansible-playbook -i ansible/inventory.ini ansible/playbook_global.yml
